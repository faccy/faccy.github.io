{"pages":[],"posts":[{"title":"回溯法","text":"回溯法 回溯法，简单的来说，就是搜索所有可能的解得过程中，如果搜索到某一结点不满足条件了，就回溯至上一个结点，改变上一个结点的值（或选择），然后继续搜索，不断重复此过程直至求出所有符合题意的解。 回溯法解决的问题都包含着选择，因此其解空间常用树来表示，搜索解空间树的过程，其实就是遍历这棵解空间树的过程。我们都知道，遍历树有递归和非递归两种方式，对应的回溯法的框架也是两种。 递归框架12345678910111213int x[n];void backtrack(int i) { if(i&gt;n) 输出结果 else { for (j = 下界; j &lt;= 上界; j++) { x[i] = j; ... if (constraint(i) &amp;&amp; bound(i)) backtrack(i + 1); } }} 我们看一个具体的例子尝试来理解这个框架。 现在有一个含n个整数的数组a，无相同元素，设计算法求其所有子集。例如a[]={1,2,3} 分析：很显然此题可以使用暴力法求解，此题的回溯法其实跟暴力法很类似。我们就用a[]={1,2,3}来分析，求子集的过程其实可以理解为三次选择，第一次是否选择1，第二次是否选择2，以此类推。 12345678910void dfs(int a[], int n, int i, int x[]) { if (i &gt; n) Disp(a,n,x); else { x[i] = 0; dfs(a, n, i + 1, x); x[i] = 1; dfs(a, n, i + 1, x); }} 其中数组x是用来记录对应的数组a元素是否被选中的。注意看else中的内容，x[i]=0表示对应的a[i]不被选中，然后搜索下一层，当下一层搜索完成，回溯到本层，又选中a[i]，继续下一层的搜索。 回到上面的递归框架，会发现里面有两个函数我们还没有用到，constraint和bound，它们分别为约束条件和限界函数。约束函数用于选取满足条件的一个解，限界函数用于剪去不可能存在解得结点。这两个函数统称剪枝函数，顾名思义就是剪去解空间树上不符合题目要求的结点及其子结点。例题中没有回溯的原因正是题目没有对解进行约束限制，而在实际应用中，这种限制是经常存在的，如果现在我们要求找出最多包含两个元素的子集，又该如何处理呢？ 分析：新加入的限制就是一个限界函数，它要求我们保证子集的元素个数在两个及以下，反馈到代码中就是要求最后数组x的和要小于等于2，于是乎我们给递归过程加上一个if语句进行限制。 123456789101112131415161718192021bool bound(int n,int x[]) { int sum = 0; for (int i = 0; i &lt; n; i++) sum += x[i + 1]; if (sum &lt;= 2) return true; else return false;}void dfs(int a[], int n, int i, int x[]) { if (i &gt; n) Disp(a,n,x); else { x[i] = 0; if(bound(i,x)) dfs(a, n, i + 1, x); x[i] = 1; if (bound(i,x)) dfs(a, n, i + 1, x); }} 可以看到代码中添加了一个bound函数，用来判断子集中的元素是否已经大于两个，这样就剪去了元素个数大于2的子集的结点，即上文提到的“剪枝”。 非递归框架1234567891011121314151617int x[n];void backtrack(int n) { int i = 1; while (i &gt;= 1) { if (ExistSonNode(t)) { for (j = 下界; j &lt;= 上界; j++) { x[i]取一个可能的值 if (constraint(i) &amp;&amp; bound(i)) { if (x是一个可行解) 输出x else i++; } } } else i--; }} 我们不难看出，非递归框架是通过下标的变化来实现搜索的回溯的，例题的非递归实现如下： 12345678910111213141516void backtrack(int a[],int n,int x[]){ int i = 1; for (int i1 = 0; i1 &lt; 2; i1++) { x[i] = i1; i++; for (int i2 = 0; i2 &lt; 2; i2++) { x[i] = i2; i++; for (int i3 = 0; i3 &lt; 2; i3++) { x[i] = i3; if (bound(n, x)) Disp(a, n, x); } i--; } i--; }} 例题著名的n皇后问题就非常适合用回溯法的思想来求解。 在n*n的方格棋盘上放置n个皇后，要求每个皇后不同行、不同列、不同左右对角线。 分析：可以定义一个数组，用来存放皇后的位置，下标代表行数，值代表列数，如q[2]=3就表示第二行第三列放置了一个皇后。那么这个数组就是我们的解空间，第一行任取一个不大于n的值，第二行任取不与第一个冲突的值… 实现代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;#define MAX 20int q[MAX];int n = 4;void Disp(){ for (int i = 1; i &lt;= n; i++) cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; q[i] &lt;&lt; &quot;)&quot; &lt;&lt; endl;}bool bound(int i, int j) { if (i == 1) return true; for (int k = 1; k &lt; i; k++) { if (q[k] == j) return false; if (abs(k - i) == abs(q[k] - q[i])) return false; } return true;}void queens(int i) { if (i &gt; n) Disp(); else{ for (int j = 1; j &lt;= 4; j++) { q[i] = j; if (bound(i, j)) queens(i + 1); } }}int main(){ queens(1); return 0;}","link":"/2021/01/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"title":"动态规划","text":"什么是动态规划我们首先看一下递归求斐波那契数列的函数： 123456int fib(int n){ if (n == 1 || n == 2) return 1; else return fib(n - 1) + fib(n - 2);} 假设我们输入的参数是5，那么求解过程为： 会发现其中有重复的计算，如fib(3)就算了两次，如果我们将规模扩大，那么重复的计算会更多。 为了避免重复计算，我们可以创建一个全局数组，存储fib(n)的值，当需要fib(n)时，可直接参与运算，而不需要再次递归。 12345678#define Max 20int dp[Max] = { 0 };int fib(int n) { dp[1] = dp[2] = 1; for (int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n];} 这样就使时间复杂度从指数级降为了O(n),大大提高了算法效率。这就是经典的动态规划算法的应用。 动态规划的适用问题动态规划的核心思想就是把多阶段的过程转化为很多单阶段过程，利用各阶段之间的关系求解。 动态规划算法的使用要包含3个条件： （1）最优性原理：指问题的最优解所包含的子问题的解也是最优的，这样便可通过最优子问题的解最终求出问题的最优解。 （2）无后效性：一个确定了的状态不受后面状态的影响，比如一旦求出fib(3)=2,它就一直等于2，与之后的计算无关。 （3）有重叠子问题：即子问题之间有联系，比如斐波那契数列中新的一项等于前两项之和。 例题求将正整数n无序拆分成最大数为k的拆分方案个数，要求所有的拆分方案不重复。 分析：首先我们看能否将这个问题转化为多个单阶段过程，题目要求最大值为k，那么我们可以将拆分分为两种：一种包含k；另一种不包含k。对于包含k的方案，可以理解为一个k和后面剩余的数，而后面的数中还有可能再次出现k,就相当于在把后面和为n-k的数进行拆分，最大值为k；假设存在一个函数f(n,k)能表示题目要求的拆分次数，那么包含k的方案就有f(n-k,k)种。同样，对于不包含k的方案，既然不包含他的最大值，我们就可以直接将其最大值改为k-1，即f(n,k-1);这样，我们就找到了当前状态与前面状态的关系：f(n,k)=f(n-k,k)+f(n,k-1),很显然它满足我们上面所说的3个条件，那么就可以使用动态规划求解。 确定了可以使用动态规划之后，最重要的一步就是找到状态方程，也就是前后子问题之间的关系。在上面推出的f(n,k)=f(n-k)+f(n,k-1)只是我们默认n&gt;k且n,k均不唯一的情况。完整考虑得出的状态方程如下： f(n,k)= 1 n=1 or k=1f(n,n) n&lt;kf(n,n-1)+1 n=kf(n-k,k)+f(n,k-1) n&gt;k 代码如下： 12345678910111213141516#define Max 20int dp[Max][Max] = { 0 };int solve(int n,int k) { for(int i=1;i&lt;=n;i++) for (int j = 1; j &lt;= k; j++) { if (i == 1 || j == 1) dp[i][j] = 1; if (i &lt; j) dp[i][j] = dp[i][i]; else if (i == j) dp[i][j] = dp[i][i-1]+1; else dp[i][j] = dp[i - j][j] + dp[i][j - 1]; } return dp[n][k];} 此题也可以使用递归解决，读者可自行尝试，比较体会动态规划算法的优越性。 补充动态规划在一些情况下可以进行空间上的优化。比如最初的求斐波那契数列的问题，我们可以发现，实际参与计算就是三个量：fib(n),fib(n-1)和fib(n-2)，但是我们却使用了长度至少为n的数组。实际上我们只需要定义一个长度为3的数组，通过数组的循环滚动使用来完成计算，我们称其为滚动数组。 代码如下： 1234567int dp[3] = { 0 };int fib(int n) { dp[1] = dp[2] = 1; for (int i = 3; i &lt;= n; i++) dp[i%3] = dp[(i - 1)%3] + dp[(i - 2) % 3]; return dp[n % 3];}","link":"/2021/01/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[],"categories":[]}